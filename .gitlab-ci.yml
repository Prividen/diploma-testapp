variables:
  INFRA_PROJECT_PATH: netology-diploma/infra
  INFRA_ARTIFACT_SOURCE_JOB: save-artifacts
  INFRA_CNT_IMAGE: "${CI_REGISTRY}/${INFRA_PROJECT_PATH}/infra-container"
  APP_NAME: testapp
  NO_DEPLOY: 0
  DEBUG: 1
  #USE_DEPLOY_ENV: prod

stages:
  - build
  - test
  - deploy

build-docker-image:
  image: docker:git
  stage: build
  services:
    - docker:dind
  before_script: &before_script
    - INFRA_PROJECT_API="${CI_API_V4_URL}/projects/$(echo $INFRA_PROJECT_PATH |sed -e 's|/|%2F|g')/jobs/artifacts/master/download"
    - echo $INFRA_PROJECT_API
    - wget --header "JOB-TOKEN:$CI_JOB_TOKEN" ${INFRA_PROJECT_API}?job=${INFRA_ARTIFACT_SOURCE_JOB} -O .artifacts.zip
    - unzip .artifacts.zip && rm -f .artifacts.zip
    - chmod 0600 admin-*.conf infra-info.yaml
    - export CONTAINER_REGISTRY=$(grep '^container_registry:' infra-info.yaml |cut -f2 -d' ')
    - export DOCKER_REGISTRY_KEY=$(grep '^docker_registry_agent_key:' infra-info.yaml |cut -f2 -d' ' |base64 -d)
    - export DEPLOY_ENV_INHERITED=$(grep '^deploy_env:' infra-info.yaml |cut -f2 -d' ')
      # by default, DEPLOY_ENV is 'stage'
    - export DEPLOY_ENV=stage
      # if deployment called from infra project, will use inherited cluster value
    - if [ "$CI_PIPELINE_SOURCE" = "pipeline" ]; then export DEPLOY_ENV=$DEPLOY_ENV_INHERITED; fi
      # if it tag release, then DEPLOY_ENV is 'prod'
    - if [ -n "$CI_COMMIT_TAG" ]; then export DEPLOY_ENV=prod; fi
      # but we always can reassign this behaviour with USE_DEPLOY_ENV CI env
    - if [ -n "$USE_DEPLOY_ENV" ]; then export DEPLOY_ENV=$USE_DEPLOY_ENV; fi
    - |
      if [ "$DEPLOY_ENV" = "prod" -a -z "$CI_COMMIT_TAG" ]; then
        last_tag=$(git tag -l --sort="version:refname" |tail -1)
        git checkout $last_tag
        export CI_COMMIT_TAG=$last_tag
      fi
  script:
    - cd ${APP_NAME}/docker
    - docker build --pull -t ${CONTAINER_REGISTRY}/${APP_NAME}:latest ./
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        for TAG in ${CI_COMMIT_TAG} stable; do
          docker tag ${CONTAINER_REGISTRY}/${APP_NAME}:latest ${CONTAINER_REGISTRY}/${APP_NAME}:${TAG}
        done
      fi

test-docker-image:
  image: docker:git
  stage: test
  services:
    - docker:dind
  before_script: *before_script
  script:
    - docker run --name test_build --rm -d -p 18080:80 ${CONTAINER_REGISTRY}/${APP_NAME}:latest
    - sleep 5s
    - wget -q docker:18080 -O - |grep 'Default index'
  after_script:
    - docker kill test_build
  dependencies:
    - build-docker-image

validate-testapp-env:
  image: $INFRA_CNT_IMAGE
  stage: test
  before_script: *before_script
  script:
    - ansible-playbook -e @infra-info.yaml -e build_ref=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA} -e deploy_env=$DEPLOY_ENV prepare.yaml validate.yaml

push-docker-image:
  image: docker:git
  stage: deploy
  services:
    - docker:dind
  before_script: *before_script
  script:
    - echo "$DOCKER_REGISTRY_KEY" |docker login -u json_key --password-stdin cr.yandex
    - docker push ${CONTAINER_REGISTRY}/${APP_NAME}:latest
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        for TAG in ${CI_COMMIT_TAG} stable; do
          docker push ${CONTAINER_REGISTRY}/${APP_NAME}:${TAG}
        done
      elif [ "$CI_PIPELINE_SOURCE" = "pipeline" -a "$DEPLOY_ENV" = "prod" ]; then
          docker push ${CONTAINER_REGISTRY}/${APP_NAME}:stable
      fi
  dependencies:
    - build-docker-image
    - test-docker-image


deploy-testapp:
  stage: deploy
  image: $INFRA_CNT_IMAGE
  before_script: *before_script
  script:
    - err_ex() { retcode=$?; echo "error-> $*" >&2; [ "$DEBUG" = "1" ] && (echo "wait for debug";sleep 1h||true); exit $retcode; }
    - trap "err_ex" ERR
    - ansible-playbook -e @infra-info.yaml -e build_ref=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA} -e deploy_env=$DEPLOY_ENV prepare.yaml deploy.yaml
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_PIPELINE_SOURCE == "pipeline" || $CI_PIPELINE_SOURCE == "web"
    - if: $NO_DEPLOY == "1"
      when: never
    - when: never
